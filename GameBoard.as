/*		Copyright (c) 2011 Eric Kaggen	Permission is hereby granted, free of charge, to any person obtaining a copy	of this software and associated documentation files (the "Software"), to deal	in the Software without restriction, including without limitation the rights	to use, copy, modify, merge, publish, distribute, sublicense, and/or sell	copies of the Software, and to permit persons to whom the Software is	furnished to do so, subject to the following conditions:	The above copyright notice and this permission notice shall be included in	all copies or substantial portions of the Software.	THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR	IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,	FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE	AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER	LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,	OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN	THE SOFTWARE.*/package{	import board_items.*;		import flash.display.MovieClip;	import flash.events.KeyboardEvent;	import flash.filters.GlowFilter;
	// A game board. Contains logic for drawing and interacting with the board.	public class GameBoard extends MovieClip	{		// Keycodes for the arrow keys		public static const KEY_LEFT:int = 37;		public static const KEY_RIGHT:int = 39;				public var main:LaserQuestMain		protected var startSquares:Array; // The squares where lasers originate from (used to draw them)		protected var endNodes:Array;				public var selected:BoardSquare = null;		public var squares:Array;		public var laser_mc:MovieClip;				public var orbs:Array;				public var level:GameLevel;		public var creationTray:CreationTray;				// Saved values		public var rows:Number;		public var cols:Number		public var lineThickness:Number;		protected var victory:Boolean = false;		protected var boardActive:Boolean = false;				public function GameBoard()		{			super();			laser_mc = new MovieClip();			addChild(laser_mc);			laser_mc.x = 0;			laser_mc.y = 0;		}				public function reset()		{			if(squares != null)			{				initialize(rows, cols, lineThickness);				drawLasers();			}		}				// For re-initialization		public function clearBoard()		{			clearLasers();			changeSelection(null);			orbs = new Array();			victory = false;						for(var i = 0; i < squares.length; i++)			{				for(var j = 0; j < squares[i].length; j++)				{					var currentSquare:BoardSquare = squares[i][j];					currentSquare.beams = new Array();					currentSquare.setHighlight(false);					if(currentSquare.item != null)					{						currentSquare.item.removeEventListeners();						currentSquare.removeItem();					}					currentSquare.removeGhost();				}			}		}				protected function triggerVictory()		{			main.victory(this);		}				// Draws the board using a series of adjacent BoardSquares		public function initSquares(rows:Number, cols:Number, lineThickness:Number)		{			boardActive = false;			this.rows = rows;			this.cols = cols;			this.lineThickness = lineThickness;			if(squares != null)			{				clearBoard();			}						var __x:Number;			var __y:Number;			squares = new Array(cols);			for(__x = 0; __x < cols; __x++)			{				squares[__x] = new Array(rows);				for(__y = 0; __y < rows; __y++)				{					var newSquare:BoardSquare = new BoardSquare(this, __x, __y);					addChild(newSquare);					var xC = __x * (newSquare.width - lineThickness);					var yC = __y * (newSquare.height - lineThickness);					newSquare.x = xC;					newSquare.y = yC;					squares[__x][__y] = newSquare;				}			}		}				// Initializes and draws the game board		public function initialize(rows:Number, cols:Number, lineThickness:Number)		{			initSquares(rows, cols, lineThickness);			// Set up the level			if(level != null)			{				var i:Number;				level.init(this);				for(i = 0; i < level.gameItems.length; i++)				{					if(level.gameItems[i].active)					{						addItem(level.gameItems[i]);					}				}								if(creationTray != null)				{					creationTray.reset();					for(i = 0; i < level.generators.length; i++)					{						creationTray.addGenerator(level.generators[i].item, level.generators[i].name, level.generators[i].amount);					}				}				boardActive = true;			}			else			{				main.noLevel(this);			}					}				// Handles changes of selection (when user clicks an item or clicks off a selected item)		public function changeSelection(source:BoardSquare)		{			// Deselect the old selected thing			if(selected != null)			{				selected.setSelected(false);			}			if(selected != source && source != null) // Not trying to deselected current selected			{				selected = source;				bringToFront(source);				selected.setSelected(true);			}			else // Deselecting current			{				selected = null;			}		}				public function dropItem(item:BoardItem, target:BoardSquare):Boolean		{			return true;		}				public function postItemDrop()		{					}		public function rotateItem(amount:Number)		{			if(selected != null && !selected.item.lockRotate)			{				selected.item.orientation = (selected.item.orientation + amount + 360) % 360;				selected.item.rotation = -selected.item.orientation;								drawLasers();			}		}		public function bringToFront(target:MovieClip)		{			this.setChildIndex(target, this.numChildren - 1);		}		public function addItem(item:BoardItem)		{			item.putInSquare();		}				public function removeItem(item:BoardItem)		{			item.removeFromSquare();		}		private function calculateLasers()		{			startSquares = new Array();			endNodes = new Array(); // For visually finishing off beams			orbs = new Array(); // Keep track of orbs			var queue:Array = new Array() // The queue of beam nodes that we need to process			/*				Initialization				- Search all squares for laser beams			*/			for(var i = 0; i < squares.length; i++)			{				for(var j = 0; j < squares[i].length; j++)				{					var currentSquare:BoardSquare = BoardSquare(squares[i][j]);					currentSquare.beams = new Array(); // Reset beams					if(currentSquare.item != null) // Check if this item is a laser gun					{						if(currentSquare.item is LaserGun)						{							var laser:LaserGun = LaserGun(currentSquare.item);							// This is a start square							startSquares.push(currentSquare);														// Lets leave open the possibility that the laser to emit multiple beams							var beamNodes:Array = laser.getBeams();							while(beamNodes.length > 0)							{								queue.push(beamNodes.pop());							}						}						if(currentSquare.item is Orb)						{							orbs.push(currentSquare.item);						}					}				}			}			/*				- Processing				Now process until the queue is empty (BFS)			*/			while(queue.length > 0)			{				// The current square that we're processing				var node:BeamNode = queue.shift();								// An array of every square that the beam will go into after this square				var next:Array;												// Test if this is an empty square, get a simulated next array for it				if(node.source.item == null)				{					next = emptySquareNext(node);				}				else				{					next = node.source.item.next(node);				}								// Go through all next nodes to draw segments to them				while(next.length > 0)				{					var nextNode:BeamNode = next.shift();										// Is this the end of the map? (only thing that causes source = null)					if(nextNode.source == null)					{						// Have this small ending segment take the direction of what would have been the next node						// so that beams don't go off the map						node.direction = nextNode.direction; 												// Set to the color to the true (displayed) color of this node						node.color = node.trueColor;												var foundMatch:Boolean = false;						for(var i in endNodes)						{							// Make sure they are going in the same direction before combining							if(endNodes[i].source == node.source && endNodes[i].direction == node.direction)							{								foundMatch = true;								endNodes[i].color |= node.color; // Combine color								break;							}						}												if(!foundMatch)						{							// Add to the end nodes list							endNodes.push(node);						}						continue;					}					var square1:BoardSquare = node.source;					var square2:BoardSquare = nextNode.source;										var activeEdge:BeamEdge = null;					var skip:Boolean = true;										// See if there's an existing beam which overlaps this next segment					for(var i = 0; i < square1.beams.length; i++)					{						var beam:BeamEdge = square1.beams[i];												// Test this beam to see if its two endpoints are equal to our sq1 and sq2						if((beam.square1 == square1 && beam.square2 == square2) || // Forward direction						(beam.square2 == square1 && beam.square1 == square2)) // Backward direction						{							// Combine the colors!//							nextNode.color |= beam.color; // Comment this out so that original color propagates														// Set the active edge to this existing beam							activeEdge = beam;														// If the existing beam matches color we don't need to draw this, skip it							if(beam.color == node.trueColor)							{								if(beam.square1 == square1 && beam.square2 == square2) // Bandaid fix for same color race issue.								{									continue;								}							}							skip = false;						}					}					// No existing beams? Create an active edge					if(activeEdge == null)					{						activeEdge = new BeamEdge();						activeEdge.square1 = square1;						activeEdge.square2 = square2;						activeEdge.outgoingDirection = nextNode.direction;												square1.beams.push(activeEdge);						square2.beams.push(activeEdge);					}					else if(skip)					{						continue;					}										// Combine colors					activeEdge.color |= nextNode.color;					nextNode.trueColor = activeEdge.color; // Keep track of the true color so we can draw ends										queue.push(nextNode);				}			}		}				private function clearLasers()		{			while(laser_mc.numChildren > 0)			{				laser_mc.removeChildAt(0);			}		}		public function drawLasers()		{			if(victory)			{				return;			}			clearLasers();			calculateLasers();						var queue:Array = new Array() // The queue of beam edges we need to process						// Populate the queue from all start positions			for(var i:Number = 0; i < startSquares.length; i++)			{				for(var j in startSquares[i].beams)				{					queue.push(startSquares[i].beams[j]);				}							}						// Draw all in the queue			while(queue.length > 0)			{				var node:BeamEdge = queue.shift();				if(node.drawn) // visited				{					continue;				}				drawBeam(node.square1.gridX, node.square1.gridY, node.square2.gridX, node.square2.gridY, node.color);				node.drawn = true;								// Find neighbor beams on the dest square				for(var i:Number = 0; i < node.square2.beams.length; i++)				{					var queueNode:BeamEdge = node.square2.beams[i];					// If it hasn't been drawn put it in the queue					if(!queueNode.drawn)					{						queue.push(queueNode);						//trace("Pushed node from " + queueNode.square1.gridX + "," + queueNode.square1.gridY + " to " + queueNode.square2.gridX + "," + queueNode.square2.gridY);					}				}			}						// A reference square for width \ height			var refSq:BoardSquare = new BoardSquare(null, -1, -1, false);						// Now visually finish them all off by applying a filter to the layer			while(endNodes.length > 0)			{				var endNode:BeamNode = endNodes.shift();				var glow:GlowFilter = new GlowFilter();				glow.color = endNode.color;				glow.alpha = 1;				glow.blurX = 7;				glow.blurY = 7;				glow.strength = 3;				glow.quality = 2;								var laserLayer:MovieClip = new MovieClip();				laserLayer.filters = new Array(glow);								//draw laser				laserLayer.graphics.lineStyle(2, endNode.color, 75);				laserLayer.graphics.moveTo(0, 0); // Local coordinate 0,0								var endX:Number;				var endY:Number;								if(endNode.direction == BoardItem.EAST)			{ endX = refSq.width/2-2; endY = 0; }				if(endNode.direction == BoardItem.NORTH_EAST) 	{ endX = refSq.width/2-2; endY = -refSq.height/2+2; }				if(endNode.direction == BoardItem.NORTH) 		{ endX = 0; endY = -refSq.height/2+2; }				if(endNode.direction == BoardItem.NORTH_WEST)	{ endX = -refSq.width/2+2; endY = -refSq.height/2+2; }				if(endNode.direction == BoardItem.WEST)			{ endX = -refSq.width/2+2; endY = 0; }				if(endNode.direction == BoardItem.SOUTH_WEST)	{ endX = -refSq.width/2+2; endY = refSq.height/2-2; }				if(endNode.direction == BoardItem.SOUTH)		{ endX = 0; endY = refSq.height/2-2; }				if(endNode.direction == BoardItem.SOUTH_EAST)	{ endX = refSq.width/2-2; endY = refSq.height/2-2; }//				trace("Laser at " + endX + "," + endY);				laserLayer.graphics.lineTo(endX, endY);								laserLayer.x = endNode.source.x;				laserLayer.y = endNode.source.y;//				laserLayer.x = 50;//				laserLayer.y = 50;				laser_mc.addChild(laserLayer);			}			if(testVictory())			{				triggerVictory();			}		}				private function testVictory():Boolean		{			if(!boardActive)			{				victory = false;				return false;			}			var allOrbsDone:Boolean = true;			for(var i in orbs)			{				orbs[i].calculateState();				if(!orbs[i].orbDone)				{					allOrbsDone = false;				}			}			victory = allOrbsDone;			return victory;		}		private function drawBeam(x1:Number, y1:Number, x2:Number, y2:Number, color:Number)		{//			trace("Laser from " + x1 + "," + y1 + " to " + x2 + "," + y2);			//Glow Filter: credit to laser beam demo			var glow:GlowFilter = new GlowFilter();			glow.color = color;			glow.alpha = 1;			glow.blurX = 7;			glow.blurY = 7;			glow.strength = 3;			glow.quality = 2;						var laserLayer:MovieClip = new MovieClip();			laserLayer.filters = new Array(glow);						//draw laser			laserLayer.graphics.lineStyle(2, color, 75);			laserLayer.graphics.moveTo(0, 0); // Local coordinate 0,0			laserLayer.graphics.lineTo(squares[x2][y2].x - squares[x1][y1].x,				squares[x2][y2].y - squares[x1][y1].y);						laserLayer.x = squares[x1][y1].x;			laserLayer.y = squares[x1][y1].y;			laser_mc.addChild(laserLayer);		}				// A dummy next square. Used as a sentinel for beam drawing.		private function emptySquareNext(node:BeamNode):Array		{			// Coordinate based direction			var xDir:Number;			var yDir:Number;						// New Coordiantes			var x:Number = node.source.gridX;			var y:Number = node.source.gridY;						if(node.direction == BoardItem.EAST)			{ xDir = 1; yDir = 0; }			if(node.direction == BoardItem.NORTH_EAST) 	{ xDir = 1; yDir = -1; }			if(node.direction == BoardItem.NORTH) 		{ xDir = 0; yDir = -1; }			if(node.direction == BoardItem.NORTH_WEST)	{ xDir = -1;yDir = -1; }			if(node.direction == BoardItem.WEST)			{ xDir = -1;yDir = 0; }			if(node.direction == BoardItem.SOUTH_WEST)	{ xDir = -1;yDir = 1; }			if(node.direction == BoardItem.SOUTH)		{ xDir = 0; yDir = 1; }			if(node.direction == BoardItem.SOUTH_EAST)	{ xDir = 1;	yDir = 1; }						x += xDir;			y += yDir;						// Limits			var xLimit:Number = squares.length;			var yLimit:Number = squares[0].length;						var nextSquare:BoardSquare = null;			if(x >= 0 && x < xLimit && y >= 0 && y < yLimit)			{				nextSquare = squares[x][y];			}						return new Array(new BeamNode(nextSquare, node.direction, node.color));		}				public function keyDownListener(event:KeyboardEvent)		{			if(victory)			{				return;			}			if(event.keyCode == KEY_LEFT)			{				rotateItem(45);			}			else if(event.keyCode == KEY_RIGHT)			{				rotateItem(-45);			}		}	}}